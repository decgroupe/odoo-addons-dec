# Copyright (C) DEC SARL, Inc - All Rights Reserved.
# Written by Yann Papouin <ypa at decgroupe.com>, Mar 2021

from odoo import _, api, fields, models


class MrpProduction(models.Model):
    _inherit = "mrp.production"

    purchase_line_ids = fields.Many2many(
        comodel_name="purchase.order.line",
        relation="purchase_order_line_mrp_rel",
        column1="production_id",
        column2="purchase_line_id",
        string="Subcontracted Services",
        readonly=True,
        copy=False,
        help="Purchase line generated by this Production Order",
    )

    def _prepare_service_procurement_values(self, bom_line):
        self.ensure_one()
        location = self.location_src_id
        return {
            "company_id": self.company_id,
            "date_planned": self.date_planned_start,
            "warehouse_id": location.get_warehouse(),
            "group_id": self.procurement_group_id,
            "production_id": self,
            "bom_line_id": bom_line,
        }

    def _post_bom_line_procurement_fail(self, bom_line):
        if not self.env.context.get("procurement_fail_no_notify"):
            message = _(
                "The procurement workflow for this line is not supported: "
                "<a href=# data-oe-model=mrp.bom.line "
                "data-oe-id=%d>%s</a>"
            ) % (bom_line.id, bom_line.display_name)
            self.message_post(body=message)

    @api.model
    def _action_launch_procurement_rule(self, bom_line, line_data):
        """This function was initially defined in `mrp_production_service` module"""
        self.ensure_one()
        if bom_line.product_id.purchase_ok:
            ProcurementGroup = self.env["procurement.group"]
            procurement_requests = []
            values = self._prepare_service_procurement_values(bom_line)
            origin = self.name
            procurement_requests.append(
                ProcurementGroup.Procurement(
                    bom_line.product_id,
                    line_data["qty"],
                    bom_line.product_uom_id,
                    self.location_src_id,
                    self.name or "/",
                    origin,
                    self.company_id,
                    values,
                )
            )
            # warning: because of `stock_procurement_group_hook`, this is the hooked
            # `run_new` function that will be called
            ProcurementGroup.run(procurement_requests)
            res = True
        else:
            self._post_bom_line_procurement_fail(bom_line)
            res = False
        return res

    def action_confirm(self):
        """Instead of overriding `_get_moves_raw_values` (that can be triggered more
        than once), we overrides `action_confim` that should be called once. This way,
        it is not necessary to add a tracking layer."""
        res = super().action_confirm()
        for production in self:
            production._create_services()
        return res

    def _create_services(self):
        factor = (
            self.product_uom_id._compute_quantity(
                self.product_qty, self.bom_id.product_uom_id
            )
            / self.bom_id.product_qty
        )
        _boms, lines = self.bom_id.explode(
            self.product_id,
            factor,
            picking_type=self.bom_id.picking_type_id,
        )
        for bom_line, line_data in lines:
            if bom_line.product_id.type == "service":
                self._action_launch_procurement_rule(bom_line, line_data)

    def action_cancel(self):
        result = super().action_cancel()
        self.sudo()._activity_cancel_on_purchase()
        return result

    def _activity_cancel_on_purchase(self):
        """If some MO are cancelled, we need to put an activity on their
        generated purchase. If sale lines of differents production orders
        impact different purchase, we only want one activity to be
        attached.
        """
        purchase_to_notify_map = (
            {}
        )  # map PO -> recordset of POL as {purchase.order: set(mrp.production)}

        purchase_order_lines = self.env["purchase.order.line"].search(
            [
                ("id", "in", self.mapped("purchase_line_ids").ids),
                ("state", "!=", "cancel"),
            ]
        )
        for purchase_line in purchase_order_lines:
            purchase_to_notify_map.setdefault(
                purchase_line.order_id, self.env["purchase.order.line"]
            )
            purchase_to_notify_map[purchase_line.order_id] |= purchase_line

        for purchase_order, purchase_lines in purchase_to_notify_map.items():
            purchase_order._activity_schedule_with_view(
                "mail.mail_activity_data_warning",
                user_id=purchase_order.user_id.id or self.env.uid,
                views_or_xmlid="mrp_purchase.exception_purchase_on_mrp_cancellation",
                render_context={
                    "production_orders": purchase_lines.mapped("production_id"),
                    "purchase_order_lines": purchase_lines,
                },
            )
