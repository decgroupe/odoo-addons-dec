# -*- coding: utf-8 -*-
# Copyright (C) DEC SARL, Inc - All Rights Reserved.
# Written by Yann Papouin <ypa at decgroupe.com>, Aug 2020

import logging

from odoo import api, fields, models, _

from odoo.exceptions import UserError, MissingError

_logger = logging.getLogger(__name__)


class ProcurementGroup(models.Model):
    _inherit = 'procurement.group'

    @api.model
    def _run_scheduler_tasks(self, use_new_cursor=False, company_id=False):
        # Check confirmed moves in MO or pickings
        self.sudo()._try_mts_moves_without_orderpoint(
            use_new_cursor=use_new_cursor, company_id=company_id
        )
        super(ProcurementGroup, self)._run_scheduler_tasks(
            use_new_cursor=use_new_cursor, company_id=company_id
        )

    @api.model
    def _try_mts_moves_without_orderpoint(
        self, use_new_cursor=False, company_id=False
    ):
        if company_id and self.env.user.company_id.id != company_id:
            # To ensure that the company_id is taken into account for
            # all the processes triggered by this method
            # i.e. If a PO is generated by the run of the procurements the
            # sequence to use is the one for the specified company not the
            # one of the user's company
            self = self.with_context(
                company_id=company_id, force_company=company_id
            )
        # Find and select only valid moves
        moves_to_reorder = self._get_mts_moves_to_reorder()
        for product_id in moves_to_reorder.mapped('product_id'):
            try:
                with self._cr.savepoint():
                    self._action_cannot_reorder_product(product_id)
            except UserError as error:
                self.env['stock.rule']._log_next_activity(
                    product_id, error.name
                )
        if use_new_cursor:
            self._cr.commit()

    @api.model
    def _get_mts_moves_to_reorder(self):
        # Search all active pickings
        picking_ids = self.env['stock.picking'].search(
            [('state', 'in', ('waiting', 'confirmed', 'assigned'))]
        )
        # Select only valid moves
        picking_res = self._filter_mts_picking_moves_to_reorder(picking_ids)

        # Search all active manufacturing orders
        production_ids = self.env['mrp.production'].search(
            [('state', 'not in', ('done', 'cancel'))]
        )
        # Select only valid moves
        production_res = self._filter_mts_production_moves_to_reorder(
            production_ids
        )
        return picking_res + production_res

    @api.model
    def _filter_mts_picking_moves_to_reorder(self, picking_ids):
        return picking_ids.mapped('move_lines').filtered(
            lambda x: \
            x.state in ('confirmed') and \
            x.procure_method == 'make_to_stock' and \
            x.product_id.nbr_reordering_rules == 0 and \
            x.location_id == self.env.ref('stock.stock_location_stock') and \
            x.created_purchase_line_id.id == False and \
            x.created_production_id.id == False and \
            x.orderpoint_created_production_ids.ids == [] and \
            x.orderpoint_created_purchase_line_ids.ids == []
        )

    @api.model
    def _filter_mts_production_moves_to_reorder(self, production_ids):
        return production_ids.mapped('move_raw_ids').filtered(
            lambda x: \
            x.state in ('confirmed') and \
            x.procure_method == 'make_to_stock' and \
            x.product_id.nbr_reordering_rules == 0 and \
            x.location_id == self.env.ref('stock.stock_location_stock') and \
            x.created_purchase_line_id.id == False and \
            x.created_production_id.id == False and \
            x.orderpoint_created_production_ids.ids == [] and \
            x.orderpoint_created_purchase_line_ids.ids == []
        )

    @api.model
    def _action_cannot_reorder_product(self, product_id):
        product_id.ensure_one()
        error_msg = _('Not enough stock and no minimum orderpoint rule')
        raise UserError(error_msg)
