# -*- coding: utf-8 -*-
# Copyright (C) DEC SARL, Inc - All Rights Reserved.
# Written by Yann Papouin <ypa at decgroupe.com>, Oct 2021

import logging

from odoo import _, api, fields, models
from odoo.exceptions import ValidationError

_logger = logging.getLogger(__name__)


class SoftwareLicensePass(models.Model):
    _name = 'software.license.pass'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _description = 'Application Pass'

    @api.model
    def _get_default_serial(self):
        return self.env['software.license']._generate_serial()

    @api.model
    def _get_current_user(self):
        return self.env.user

    @api.model
    def _get_default_company(self):
        return self.env.user.company_id

    active = fields.Boolean(
        'Active',
        default=True,
        help="If unchecked, it will allow you to hide the application pass "
        "without removing it.",
    )
    product_id = fields.Many2one(
        comodel_name='product.product',
        string='Product',
        help="Product at the origin of the pass",
        change_default=True,
        domain="[('license_pack_id', '!=', False)]",
        ondelete='restrict',
    )
    pack_id = fields.Many2one(
        comodel_name='software.license.pack',
        string='Pack',
        help="Pack of applications linked to the product at the origin of "
        "the pass",
        change_default=True,
        ondelete='restrict',
    )
    name = fields.Char(
        'Reference',
        copy=False,
        readonly=True,
        default=lambda x: _('New'),
    )
    state = fields.Selection(
        [
            ('draft', 'To Send'),
            ('sent', 'Sent'),
            ('cancel', 'Cancelled'),
        ],
        string='Status',
        readonly=True,
        copy=False,
        index=True,
        track_visibility='onchange',
        track_sequence=3,
        default='draft',
    )
    serial = fields.Char(
        required=True,
        copy=False,
        default=_get_default_serial,
        track_visibility='onchange',
        help="Unique serial used as an authorization identifier",
    )
    expiration_date = fields.Datetime(
        string="Expiration Date",
        track_visibility='onchange',
        help="If set, then after this date it will not be possible to "
        "proceed or renew any activation.",
    )
    max_allowed_hardware = fields.Integer(
        string="Maximum Activation Count",
        default=1,
        track_visibility='onchange',
        help="If more than 0, then the number of registered hardware "
        "identifiers will not be allowed to be greater than this value.",
    )
    company_id = fields.Many2one(
        comodel_name='res.company',
        string='Company',
        required=True,
        default=_get_default_company,
        copy=False
    )
    user_id = fields.Many2one(
        comodel_name='res.users',
        string='Responsible',
        domain="[('share', '=', False)]",
        required=False,
        default=_get_current_user,
        track_visibility='onchange',
        copy=False
    )
    origin = fields.Char(
        'Source',
        copy=False,
        help="Reference of the document that generated this pass."
    )
    partner_id = fields.Many2one(
        comodel_name='res.partner', string='Partner', copy=False
    )
    partner_zip_id = fields.Many2one(
        'res.city.zip',
        related='partner_id.zip_id',
        string="Partner's ZIP",
        store=True,
    )
    partner_city_id = fields.Many2one(
        'res.city',
        related='partner_id.city_id',
        string="Partner's City",
        store=True,
    )
    license_ids = fields.One2many(
        comodel_name='software.license',
        inverse_name='pass_id',
        string="Licences",
        copy=False,
        ondelete='cascade',
        help="Licenses dynamically generated by this pass to match pack "
        "content"
    )

    _sql_constraints = [
        (
            'serial_uniq', 'unique(serial)',
            'Serial Pass Activation Code must be unique!'
        ),
    ]

    @api.model
    def create(self, values):
        if not values.get('name', False) or values['name'] == _('New'):
            values['name'] = self.env['ir.sequence'].next_by_code(
                'software.license.pass'
            ) or _('New')
        app_pass = super(SoftwareLicensePass, self).create(values)
        return app_pass

    @api.multi
    def write(self, vals):
        self._batch_license_write(vals)
        return super().write(vals)

    @api.multi
    @api.returns('self', lambda value: value.id)
    def copy(self, default=None):
        self.ensure_one()
        if default is None:
            default = {}
        if not default.get('serial'):
            default.update(serial=_('%s (copy)') % (self.serial))
        return super(SoftwareLicensePass, self).copy(default)

    def _batch_license_write(self, vals):
        licenses_vals = {}
        if vals.get('partner_id'):
            licenses_vals['partner_id'] = vals.get('partner_id')
        if vals.get('max_allowed_hardware'):
            licenses_vals['max_allowed_hardware'] = vals.get(
                'max_allowed_hardware'
            )
        if vals.get('expiration_date'):
            licenses_vals['expiration_date'] = vals.get('expiration_date')
        if licenses_vals:
            license_ids = self.mapped('license_ids').with_context(
                override_from_pass=True
            )
            license_ids.write(licenses_vals)

    @api.multi
    def action_view(self):
        action = self.env.ref(
            'software_license_pass.act_window_software_license_pass'
        ).read()[0]
        form = self.env.ref(
            'software_license_pass.act_window_view_software_license_pass_form'
        )
        if len(self.ids) > 1:
            action['domain'] = [('id', 'in', self.ids)]
        else:
            action['views'] = [(form.id, 'form')]
            action['res_id'] = self.id
        return action

    @api.multi
    def action_cancel(self):
        self.write({'state': 'cancel'})

    @api.multi
    @api.returns('mail.message', lambda value: value.id)
    def message_post(self, **kwargs):
        if self.env.context.get('mark_as_sent'):
            self.filtered(lambda o: o.state == 'draft').with_context(
                tracking_disable=True
            ).write({'state': 'sent'})
        return super(
            SoftwareLicensePass, self.with_context(mail_post_autofollow=True)
        ).message_post(**kwargs)

    @api.multi
    def action_send(self):
        """ This function opens a window to compose an email, with the pass
        template message loaded by default
        """
        self.ensure_one()
        self.user_id = self._get_current_user()
        template_id = self.env.ref(
            'software_license_pass.email_template', False
        )
        form_id = self.env.ref('mail.email_compose_message_wizard_form', False)
        ctx = {
            'default_model': 'software.license.pass',
            'default_res_id': self.id,
            'default_use_template': bool(template_id.id),
            'default_template_id': template_id.id,
            'default_composition_mode': 'comment',
            'mark_as_sent': True,
            'model_description': _('Application Pass'),
            'custom_layout': "mail.mail_notification_light",
            'force_email': True
        }
        return {
            'type': 'ir.actions.act_window',
            'view_type': 'form',
            'view_mode': 'form',
            'res_model': 'mail.compose.message',
            'views': [(form_id.id, 'form')],
            'view_id': form_id.id,
            'target': 'new',
            'context': ctx,
        }

    def _prepare_license_vals(self, pack_line_id):
        self.ensure_one()
        return {
            'type': 'standard',
            'application_id': pack_line_id.application_id.id,
            'pass_id': self.id,
            'pack_line_id': pack_line_id.id,
            'product_id': self.product_id.id,
            'feature_ids': False,
        }

    @api.multi
    def action_resync_with_pack(self):
        for rec in self:
            for line in rec.pack_id.line_ids:
                if line not in rec.license_ids.mapped('pack_line_id'):
                    vals = rec._prepare_license_vals(line)
                    self.env['software.license'].with_context(
                        force_generate_serial=True
                    ).create(vals)
        self.mapped('license_ids').action_sync_features_with_template()
